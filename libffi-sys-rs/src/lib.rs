#![cfg_attr(not(test), no_std)]
#![doc(html_root_url = "https://docs.rs/libffi-sys/2.3.0")]
//! Low-level Rust bindings for [libffi](https://sourceware.org/libffi/)
//!
//! The C libffi library provides two main facilities: assembling calls to functions dynamically,
//! and creating closures that can be called as ordinary C functions.
//!
//! This is an undocumented wrapper, originally generated by bindgen then cleaned up manually,
//! intended as the basis for higher-level bindings.
//!
//! See [the libffi crate](https://crates.io/crates/libffi/) for a higher-level API.
//!
//! # Usage
//!
//! `libffi-sys` can either build its own copy of the libffi C library [from
//! github](https://github.com/libffi/libffi) or it can link against your systemâ€™s C libffi. By
//! default it builds its own because many systems ship with an old C libffi; this requires that you
//! have a working make, C compiler, automake, and autoconf first. If your system libffi is new
//! enough (v3.2.1 as of October 2019), you can instead enable the `system` feature flag to use
//! that. If you want this crate to build a C libffi for you, add
//!
//! ```toml
//! [dependencies]
//! libffi-sys = "2.3.0"
//! ```
//!
//! to your `Cargo.toml`. If you want to use your system C libffi, then
//!
//! ```toml
//! [dependencies.libffi-sys]
//! version = "2.3.0"
//! features = ["system"]
//! ```
//!
//! to your `Cargo.toml` instead.
//!
//! This crate supports Rust version 1.85 and later.

#![allow(
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    improper_ctypes,
    unused_imports,
    reason = "Re-export of C function names"
)]
#![allow(
    missing_docs,
    reason = "Documenting libffi's types and constants is currently not a priority."
)]

use core::ffi::{c_char, c_int, c_long, c_schar, c_uint, c_ulong, c_ushort, c_void};
use core::fmt::{self, Debug};
use core::mem::zeroed;

mod arch;
pub use arch::*;
use fmt::Formatter;

pub type ffi_arg = c_ulong;
pub type ffi_sarg = c_long;
pub type ffi_abi = u32;
pub type ffi_status = u32;
pub type ffi_type_enum = u16;

pub const FFI_64_BIT_MAX: u64 = 9_223_372_036_854_775_807;
pub const FFI_CLOSURES: u32 = 1;
pub const FFI_SIZEOF_ARG: usize = size_of::<c_long>();
// NOTE: This only differs from FFI_SIZEOF_ARG on ILP platforms, which Rust does not support
pub const FFI_SIZEOF_JAVA_RAW: usize = FFI_SIZEOF_ARG;

pub const FFI_TYPE_VOID: u16 = 0;
pub const FFI_TYPE_INT: u16 = 1;
pub const FFI_TYPE_FLOAT: u16 = 2;
pub const FFI_TYPE_DOUBLE: u16 = 3;
pub const FFI_TYPE_LONGDOUBLE: u16 = 4;
pub const FFI_TYPE_UINT8: u16 = 5;
pub const FFI_TYPE_SINT8: u16 = 6;
pub const FFI_TYPE_UINT16: u16 = 7;
pub const FFI_TYPE_SINT16: u16 = 8;
pub const FFI_TYPE_UINT32: u16 = 9;
pub const FFI_TYPE_SINT32: u16 = 10;
pub const FFI_TYPE_UINT64: u16 = 11;
pub const FFI_TYPE_SINT64: u16 = 12;
pub const FFI_TYPE_STRUCT: u16 = 13;
pub const FFI_TYPE_POINTER: u16 = 14;
pub const FFI_TYPE_COMPLEX: u16 = 15;
pub const FFI_TYPE_LAST: u16 = 15;

pub const ffi_status_FFI_OK: ffi_status = 0;
pub const ffi_status_FFI_BAD_TYPEDEF: ffi_status = 1;
pub const ffi_status_FFI_BAD_ABI: ffi_status = 2;
pub const ffi_status_FFI_BAD_ARGTYPE: ffi_status = 3;

pub const ffi_type_enum_STRUCT: ffi_type_enum = 13;
pub const ffi_type_enum_COMPLEX: ffi_type_enum = 15;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ffi_type {
    pub size: usize,
    pub alignment: c_ushort,
    pub type_: c_ushort,
    pub elements: *mut *mut ffi_type,
}

impl Default for ffi_type {
    fn default() -> Self {
        // SAFETY: Zeroed does not cause any invalid bit patterns in ffi_type.
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ffi_cif {
    pub abi: ffi_abi,
    pub nargs: c_uint,
    pub arg_types: *mut *mut ffi_type,
    pub rtype: *mut ffi_type,
    pub bytes: c_uint,
    pub flags: c_uint,

    // libffi/src/aarch64/ffitarget.h
    // #ifdef _WIN32
    // #define FFI_EXTRA_CIF_FIELDS unsigned is_variadic
    #[cfg(all(target_arch = "aarch64", target_os = "windows"))]
    pub is_variadic: c_uint,

    // libffi/src/aarch64/ffitarget.h
    // #if defined (__APPLE__)
    // #define FFI_EXTRA_CIF_FIELDS unsigned aarch64_nfixedargs
    #[cfg(all(target_arch = "aarch64", target_vendor = "apple"))]
    pub aarch64_nfixedargs: c_uint,

    // libffi/src/arm/ffitarget.h
    // #define FFI_EXTRA_CIF_FIELDS			\
    // int vfp_used;					\
    // unsigned short vfp_reg_free, vfp_nargs;	\
    // signed char vfp_args[16]			\
    #[cfg(target_arch = "arm")]
    pub vfp_used: c_int,
    #[cfg(target_arch = "arm")]
    pub vfp_reg_free: c_ushort,
    #[cfg(target_arch = "arm")]
    pub vfp_nargs: c_ushort,
    #[cfg(target_arch = "arm")]
    pub vfp_args: [c_schar; 16],

    // libffi/src/powerpc/ffitarget.h
    // #if defined (POWERPC) || defined (POWERPC_FREEBSD)
    // ...
    // # define FFI_EXTRA_CIF_FIELDS unsigned nfixedargs
    #[cfg(any(target_arch = "powerpc", target_arch = "powerpc64"))]
    pub nfixedargs: c_uint,

    // libffi/src/riscv/ffitarget.h
    // #define FFI_EXTRA_CIF_FIELDS unsigned riscv_nfixedargs; unsigned riscv_unused;
    #[cfg(any(target_arch = "riscv32", target_arch = "riscv64"))]
    pub riscv_nfixedargs: c_uint,
    #[cfg(any(target_arch = "riscv32", target_arch = "riscv64"))]
    pub riscv_unused: c_uint,

    // libffi/src/sparc/ffitarget.h
    // # define FFI_EXTRA_CIF_FIELDS  unsigned int nfixedargs
    #[cfg(target_arch = "sparc64")]
    pub nfixedargs: c_uint,
}

impl Default for ffi_cif {
    fn default() -> Self {
        // SAFETY: Zeroed does not cause any invalid bit patterns in ffi_cif.
        unsafe { zeroed() }
    }
}

#[repr(C, align(64))]
#[derive(Copy, Clone)]
pub union ffi_raw {
    pub sint: ffi_sarg,
    pub uint: ffi_arg,
    pub flt: f32,
    pub data: [c_char; FFI_SIZEOF_ARG],
    pub ptr: *mut c_void,
}

impl Default for ffi_raw {
    fn default() -> Self {
        // SAFETY: Zeroed does not cause any invalid bit patterns in ffi_raw.
        unsafe { zeroed() }
    }
}

pub type ffi_java_raw = ffi_raw;

#[repr(C, align(64))]
#[derive(Copy, Clone)]
pub union ffi_trampoline {
    pub tramp: [c_char; FFI_TRAMPOLINE_SIZE],
    pub ftramp: *mut c_void,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ffi_closure {
    pub tramp: ffi_trampoline,
    pub cif: *mut ffi_cif,
    pub fun: Option<
        unsafe extern "C" fn(
            arg1: *mut ffi_cif,
            arg2: *mut c_void,
            arg3: *mut *mut c_void,
            arg4: *mut c_void,
        ),
    >,
    pub user_data: *mut c_void,
}

/// Implements Debug manually since sometimes [`FFI_TRAMPOLINE_SIZE`] is too large.
impl Debug for ffi_closure {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        f.debug_struct("ffi_closure")
            // SAFETY: This might be undefined behavior if `tramp` is a `ftramp`. It is probably
            // okay for debug purposes, however.
            .field("tramp", unsafe { &self.tramp.tramp })
            .field("cif", &self.cif)
            .field("fun", &self.fun)
            .field("user_data", &self.user_data)
            .finish()
    }
}

impl Default for ffi_closure {
    fn default() -> Self {
        // SAFETY: Zeroed does not cause any invalid bit patterns in ffi_closure.
        unsafe { zeroed() }
    }
}

/// Warning: not tested
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ffi_raw_closure {
    pub tramp: [c_char; FFI_TRAMPOLINE_SIZE],
    pub cif: *mut ffi_cif,

    // See: https://github.com/libffi/libffi/blob/v3.4.7/include/ffi.h.in#L386
    #[cfg(not(target_arch = "x86"))]
    pub translate_args: Option<
        unsafe extern "C" fn(
            arg1: *mut ffi_cif,
            arg2: *mut c_void,
            arg3: *mut *mut c_void,
            arg4: *mut c_void,
        ),
    >,
    #[cfg(not(target_arch = "x86"))]
    pub this_closure: *mut c_void,

    pub fun: Option<
        unsafe extern "C" fn(
            arg1: *mut ffi_cif,
            arg2: *mut c_void,
            arg3: *mut ffi_raw,
            arg4: *mut c_void,
        ),
    >,
    pub user_data: *mut c_void,
}

/// Implements Debug manually since sometimes [`FFI_TRAMPOLINE_SIZE`] is too large.
impl Debug for ffi_raw_closure {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        let mut debug_struct = f.debug_struct("ffi_raw_closure");
        debug_struct
            .field("tramp", &&self.tramp[..])
            .field("cif", &self.cif);

        #[cfg(not(target_arch = "x86"))]
        debug_struct.field("translate_args", &self.translate_args);
        #[cfg(not(target_arch = "x86"))]
        debug_struct.field("this_closure", &self.this_closure);

        debug_struct
            .field("fun", &self.fun)
            .field("user_data", &self.user_data)
            .finish()
    }
}

impl Default for ffi_raw_closure {
    fn default() -> Self {
        // SAFETY: Zeroed does not cause any invalid bit patterns in ffi_closure.
        unsafe { zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ffi_java_raw_closure {
    pub tramp: [c_char; FFI_TRAMPOLINE_SIZE],
    pub cif: *mut ffi_cif,

    // See: https://github.com/libffi/libffi/blob/v3.4.7/include/ffi.h.in#L412
    #[cfg(not(target_arch = "x86"))]
    pub translate_args: Option<
        unsafe extern "C" fn(
            arg1: *mut ffi_cif,
            arg2: *mut c_void,
            arg3: *mut *mut c_void,
            arg4: *mut c_void,
        ),
    >,
    #[cfg(not(target_arch = "x86"))]
    pub this_closure: *mut c_void,

    pub fun: Option<
        unsafe extern "C" fn(
            arg1: *mut ffi_cif,
            arg2: *mut c_void,
            arg3: *mut ffi_java_raw,
            arg4: *mut c_void,
        ),
    >,
    pub user_data: *mut c_void,
}

/// Implements Debug manually since sometimes [`FFI_TRAMPOLINE_SIZE`] is too large.
impl Debug for ffi_java_raw_closure {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        let mut debug_struct = f.debug_struct("ffi_java_raw_closure");
        debug_struct
            .field("tramp", &&self.tramp[..])
            .field("cif", &self.cif);

        #[cfg(not(target_arch = "x86"))]
        debug_struct.field("translate_args", &self.translate_args);
        #[cfg(not(target_arch = "x86"))]
        debug_struct.field("this_closure", &self.this_closure);

        debug_struct
            .field("fun", &self.fun)
            .field("user_data", &self.user_data)
            .finish()
    }
}

impl Default for ffi_java_raw_closure {
    fn default() -> Self {
        // SAFETY: Zeroed does not cause any invalid bit patterns in ffi_closure.
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ffi_go_closure {
    pub tramp: *mut c_void,
    pub cif: *mut ffi_cif,
    pub fun: Option<
        unsafe extern "C" fn(
            arg1: *mut ffi_cif,
            arg2: *mut c_void,
            arg3: *mut *mut c_void,
            arg4: *mut c_void,
        ),
    >,
}

impl Default for ffi_go_closure {
    fn default() -> Self {
        // SAFETY: Zeroed does not cause any invalid bit patterns in ffi_closure.
        unsafe { zeroed() }
    }
}

unsafe extern "C" {
    pub static mut ffi_type_void: ffi_type;
    pub static mut ffi_type_uint8: ffi_type;
    pub static mut ffi_type_sint8: ffi_type;
    pub static mut ffi_type_uint16: ffi_type;
    pub static mut ffi_type_sint16: ffi_type;
    pub static mut ffi_type_uint32: ffi_type;
    pub static mut ffi_type_sint32: ffi_type;
    pub static mut ffi_type_uint64: ffi_type;
    pub static mut ffi_type_sint64: ffi_type;
    pub static mut ffi_type_float: ffi_type;
    pub static mut ffi_type_double: ffi_type;
    pub static mut ffi_type_pointer: ffi_type;

    #[cfg(not(target_arch = "aarch64"))]
    #[cfg(not(all(target_arch = "arm", target_os = "linux", target_env = "gnu")))]
    pub static mut ffi_type_longdouble: ffi_type;

    #[cfg(feature = "complex")]
    #[cfg(not(target_env = "msvc"))]
    pub static mut ffi_type_complex_float: ffi_type;

    #[cfg(feature = "complex")]
    #[cfg(not(target_env = "msvc"))]
    pub static mut ffi_type_complex_double: ffi_type;

    #[cfg(feature = "complex")]
    #[cfg(not(any(target_arch = "arm", target_env = "msvc")))]
    pub static mut ffi_type_complex_longdouble: ffi_type;

    pub fn ffi_raw_call(
        cif: *mut ffi_cif,
        fn_: Option<unsafe extern "C" fn()>,
        rvalue: *mut c_void,
        avalue: *mut ffi_raw,
    );

    pub fn ffi_ptrarray_to_raw(cif: *mut ffi_cif, args: *mut *mut c_void, raw: *mut ffi_raw);

    pub fn ffi_raw_to_ptrarray(cif: *mut ffi_cif, raw: *mut ffi_raw, args: *mut *mut c_void);

    pub fn ffi_raw_size(cif: *mut ffi_cif) -> usize;

    // See: https://github.com/libffi/libffi/blob/v3.4.7/include/ffi.h.in#L302
    #[cfg(not(target_arch = "x86"))]
    #[deprecated = "Deprecated in libffi 3.3"]
    pub fn ffi_java_raw_call(
        cif: *mut ffi_cif,
        fn_: Option<unsafe extern "C" fn()>,
        rvalue: *mut c_void,
        avalue: *mut ffi_java_raw,
    );

    #[deprecated = "Deprecated in libffi 3.3"]
    pub fn ffi_java_ptrarray_to_raw(
        cif: *mut ffi_cif,
        args: *mut *mut c_void,
        raw: *mut ffi_java_raw,
    );

    #[deprecated = "Deprecated in libffi 3.3"]
    pub fn ffi_java_raw_to_ptrarray(
        cif: *mut ffi_cif,
        raw: *mut ffi_java_raw,
        args: *mut *mut c_void,
    );

    #[deprecated = "Deprecated in libffi 3.3"]
    pub fn ffi_java_raw_size(cif: *mut ffi_cif) -> usize;

    pub fn ffi_closure_alloc(size: usize, code: *mut *mut c_void) -> *mut c_void;

    pub fn ffi_closure_free(arg1: *mut c_void);

    #[deprecated = "Deprecated in libffi 3.3, use `ffi_prep_closure_loc` instead"]
    pub fn ffi_prep_closure(
        arg1: *mut ffi_closure,
        arg2: *mut ffi_cif,
        fun: Option<
            unsafe extern "C" fn(
                arg1: *mut ffi_cif,
                arg2: *mut c_void,
                arg3: *mut *mut c_void,
                arg4: *mut c_void,
            ),
        >,
        user_data: *mut c_void,
    ) -> ffi_status;

    pub fn ffi_prep_closure_loc(
        arg1: *mut ffi_closure,
        arg2: *mut ffi_cif,
        fun: Option<
            unsafe extern "C" fn(
                arg1: *mut ffi_cif,
                arg2: *mut c_void,
                arg3: *mut *mut c_void,
                arg4: *mut c_void,
            ),
        >,
        user_data: *mut c_void,
        codeloc: *mut c_void,
    ) -> ffi_status;

    pub fn ffi_prep_raw_closure(
        arg1: *mut ffi_raw_closure,
        cif: *mut ffi_cif,
        fun: Option<
            unsafe extern "C" fn(
                arg1: *mut ffi_cif,
                arg2: *mut c_void,
                arg3: *mut ffi_raw,
                arg4: *mut c_void,
            ),
        >,
        user_data: *mut c_void,
    ) -> ffi_status;

    pub fn ffi_prep_raw_closure_loc(
        arg1: *mut ffi_raw_closure,
        cif: *mut ffi_cif,
        fun: Option<
            unsafe extern "C" fn(
                arg1: *mut ffi_cif,
                arg2: *mut c_void,
                arg3: *mut ffi_raw,
                arg4: *mut c_void,
            ),
        >,
        user_data: *mut c_void,
        codeloc: *mut c_void,
    ) -> ffi_status;

    // See: https://github.com/libffi/libffi/blob/v3.4.7/include/ffi.h.in#L441
    #[cfg(not(target_arch = "x86"))]
    #[deprecated = "Deprecated in libffi 3.3"]
    pub fn ffi_prep_java_raw_closure(
        arg1: *mut ffi_java_raw_closure,
        cif: *mut ffi_cif,
        fun: Option<
            unsafe extern "C" fn(
                arg1: *mut ffi_cif,
                arg2: *mut c_void,
                arg3: *mut ffi_java_raw,
                arg4: *mut c_void,
            ),
        >,
        user_data: *mut c_void,
    ) -> ffi_status;

    // See: https://github.com/libffi/libffi/blob/v3.4.7/include/ffi.h.in#L448
    #[cfg(not(target_arch = "x86"))]
    #[deprecated = "Deprecated in libffi 3.3"]
    pub fn ffi_prep_java_raw_closure_loc(
        arg1: *mut ffi_java_raw_closure,
        cif: *mut ffi_cif,
        fun: Option<
            unsafe extern "C" fn(
                arg1: *mut ffi_cif,
                arg2: *mut c_void,
                arg3: *mut ffi_java_raw,
                arg4: *mut c_void,
            ),
        >,
        user_data: *mut c_void,
        codeloc: *mut c_void,
    ) -> ffi_status;

    pub fn ffi_prep_go_closure(
        arg1: *mut ffi_go_closure,
        arg2: *mut ffi_cif,
        fun: Option<
            unsafe extern "C" fn(
                arg1: *mut ffi_cif,
                arg2: *mut c_void,
                arg3: *mut *mut c_void,
                arg4: *mut c_void,
            ),
        >,
    ) -> ffi_status;

    pub fn ffi_call_go(
        cif: *mut ffi_cif,
        fn_: Option<unsafe extern "C" fn()>,
        rvalue: *mut c_void,
        avalue: *mut *mut c_void,
        closure: *mut c_void,
    );

    pub fn ffi_prep_cif(
        cif: *mut ffi_cif,
        abi: ffi_abi,
        nargs: c_uint,
        rtype: *mut ffi_type,
        atypes: *mut *mut ffi_type,
    ) -> ffi_status;

    pub fn ffi_prep_cif_var(
        cif: *mut ffi_cif,
        abi: ffi_abi,
        nfixedargs: c_uint,
        ntotalargs: c_uint,
        rtype: *mut ffi_type,
        atypes: *mut *mut ffi_type,
    ) -> ffi_status;

    pub fn ffi_call(
        cif: *mut ffi_cif,
        fn_: Option<unsafe extern "C" fn()>,
        rvalue: *mut c_void,
        avalue: *mut *mut c_void,
    );

    pub fn ffi_get_struct_offsets(
        abi: ffi_abi,
        struct_type: *mut ffi_type,
        offsets: *mut usize,
    ) -> ffi_status;
}

#[cfg(all(test, not(miri)))]
mod test {
    use super::*;

    extern "C" fn cast_u8_u32(x: u8) -> u32 {
        x.into()
    }

    #[test]
    fn test_function_sign_extension() {
        let mut cif = ffi_cif::default();
        let mut arg_types: [*mut ffi_type; 1] = [&raw mut ffi_type_uint8];

        // SAFETY:
        // * `cif` points to a `ffi_cif`
        // * `arg_types` contains one `ffi_type` and `nargs` is 1
        // * `rtype` points to a `ffi_type`
        let prep_status = unsafe {
            ffi_prep_cif(
                &raw mut cif,
                ffi_abi_FFI_DEFAULT_ABI,
                1,
                &raw mut ffi_type_uint32,
                arg_types.as_mut_ptr(),
            )
        };

        assert_eq!(prep_status, ffi_status_FFI_OK);

        let mut rval = 0u32;
        let arg: u32 = 256;

        let func_ptr = cast_u8_u32 as *const c_void;
        let func_ptr_ptr = (&raw const func_ptr).cast::<extern "C" fn()>();

        // SAFETY:
        // * `cif` points to a `ffi_cif` with one `u8` argument and `u32` return value using the
        //   default ABI.
        // * `func` points to a function with a signature as described in `cif`, one `u8` argument,
        //   a `u32` return value and the default ABI.
        // * `rval` is a mutable `u32`.
        // * One `u16` argument is provided with the intent of verifying that only a `u8` is read,
        //   discarding bits other than the 8 least significant.
        unsafe {
            ffi_call(
                &mut cif,
                Some(*func_ptr_ptr),
                (&raw mut rval).cast(),
                [(&raw const arg).cast_mut().cast()].as_mut_ptr(),
            );
        }

        assert_eq!(rval, 0);
    }

    extern "C" fn add(x: u64, y: u64) -> u64 {
        x + y
    }

    #[test]
    fn test_function_with_two_arguments() {
        // SAFETY:
        // * cif is properly allocated
        // * type structures are properly defined
        // * `add` is a function that accept two `u64`s and returns a `u64`
        unsafe {
            let mut cif = ffi_cif::default();
            let mut arg_types: Vec<*mut ffi_type> =
                vec![&raw mut ffi_type_uint64, &raw mut ffi_type_uint64];

            let prep_status = ffi_prep_cif(
                &mut cif,
                ffi_abi_FFI_DEFAULT_ABI,
                2,
                &raw mut ffi_type_uint64,
                arg_types.as_mut_ptr(),
            );

            assert_eq!(prep_status, ffi_status_FFI_OK);

            let mut rval = 0u64;
            let func = &*core::ptr::from_ref(&(add as *mut extern "C" fn(u64, u64) -> u64))
                .cast::<extern "C" fn()>();

            ffi_call(
                &mut cif,
                Some(*func),
                (&raw mut rval).cast::<c_void>(),
                vec![
                    core::ptr::from_mut(&mut 4u64).cast::<c_void>(),
                    core::ptr::from_mut(&mut 5u64).cast::<c_void>(),
                ]
                .as_mut_ptr(),
            );

            assert_eq!(rval, 9);
        }
    }
}
